{"version":3,"file":"asyncData.1c624980.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js"],"sourcesContent":["import { getCurrentInstance, onBeforeMount, onServerPrefetch, onUnmounted, ref, toRef, unref, watch } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nconst getDefault = () => null;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  const nuxt = useNuxtApp();\n  const getCachedData = () => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key];\n  const hasCachedData = () => getCachedData() !== void 0;\n  if (!nuxt._asyncData[key]) {\n    nuxt._asyncData[key] = {\n      data: ref(getCachedData() ?? options.default()),\n      pending: ref(!hasCachedData()),\n      error: toRef(nuxt.payload._errors, key),\n      status: ref(\"idle\")\n    };\n  }\n  const asyncData = { ...nuxt._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxt._asyncDataPromises[key]) {\n      if (opts.dedupe === false) {\n        return nuxt._asyncDataPromises[key];\n      }\n      nuxt._asyncDataPromises[key].cancelled = true;\n    }\n    if ((opts._initial || nuxt.isHydrating && opts._initial !== false) && hasCachedData()) {\n      return getCachedData();\n    }\n    asyncData.pending.value = true;\n    asyncData.status.value = \"pending\";\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxt));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then((_result) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      let result = _result;\n      if (options.transform) {\n        result = options.transform(_result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n      asyncData.status.value = \"success\";\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      asyncData.error.value = error;\n      asyncData.data.value = unref(options.default());\n      asyncData.status.value = \"error\";\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      nuxt.payload.data[key] = asyncData.data.value;\n      if (asyncData.error.value) {\n        nuxt.payload._errors[key] = createError(asyncData.error.value);\n      }\n      delete nuxt._asyncDataPromises[key];\n    });\n    nuxt._asyncDataPromises[key] = promise;\n    return nuxt._asyncDataPromises[key];\n  };\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;\n  if (process.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxt.hook(\"app:created\", () => promise);\n    }\n  }\n  if (process.client) {\n    const instance = getCurrentInstance();\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (fetchOnServer && nuxt.isHydrating && hasCachedData()) {\n      asyncData.pending.value = false;\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (nuxt.payload.serverRendered && nuxt.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxt.hook(\"app:data:refresh\", (keys) => {\n      if (!keys || keys.includes(key)) {\n        return asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options] = args;\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxt = useNuxtApp();\n  if (!(key in nuxt.payload.data)) {\n    nuxt.payload.data[key] = null;\n  }\n  return {\n    data: toRef(nuxt.payload.data, key)\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (process.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? Array.isArray(keys) ? keys : [keys] : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : Array.isArray(keys) ? keys : [keys];\n  for (const key of _keys) {\n    if (key in nuxtApp.payload.data) {\n      nuxtApp.payload.data[key] = void 0;\n    }\n    if (key in nuxtApp.payload._errors) {\n      nuxtApp.payload._errors[key] = void 0;\n    }\n    if (nuxtApp._asyncData[key]) {\n      nuxtApp._asyncData[key].data.value = void 0;\n      nuxtApp._asyncData[key].error.value = void 0;\n      nuxtApp._asyncData[key].pending.value = false;\n      nuxtApp._asyncData[key].status.value = \"idle\";\n    }\n    if (key in nuxtApp._asyncDataPromises) {\n      nuxtApp._asyncDataPromises[key] = void 0;\n    }\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n"],"names":["getDefault","useAsyncData","args","autoKey","key","handler","options","nuxt","useNuxtApp","getCachedData","hasCachedData","ref","toRef","asyncData","opts","promise","resolve","reject","err","_result","result","pick","error","unref","createError","initialFetch","fetchOnServer","instance","getCurrentInstance","cbs","onBeforeMount","cb","onUnmounted","watch","off","keys","asyncDataPromise","obj","newObj"],"mappings":"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","x_google_ignoreList":[0]}